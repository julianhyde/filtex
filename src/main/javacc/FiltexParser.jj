/*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 */

options {
  STATIC = false;
  IGNORE_CASE = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(FiltexParserImpl)

package net.hydromatic.filtex.parse;

import net.hydromatic.filtex.ast.Ast;
import net.hydromatic.filtex.ast.Ast.*;
import net.hydromatic.filtex.ast.AstNode;
import net.hydromatic.filtex.ast.Op;
import net.hydromatic.filtex.ast.Pos;

import com.google.common.collect.ImmutableList;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import static net.hydromatic.filtex.ast.AstBuilder.ast;

/**
 * Parser for filter expressions, generated from FiltexParser.jj by JavaCC.
 */
public class FiltexParserImpl implements FiltexParser
{
  private static final Logger LOGGER =
      LoggerFactory.getLogger("net.hydromatic.filtex.parse");

  private int lineOffset;
  private String file = "";

  public void setTabSize(int tabSize) {
    jj_input_stream.setTabSize(tabSize);
  }

  public Pos pos() {
    return new Pos(file,
        token.beginLine - lineOffset, token.beginColumn,
        token.endLine - lineOffset, token.endColumn + 1);
  }

  public void zero(String file) {
    this.file = file;
    if (jj_input_stream.bufpos >= 0) {
      this.lineOffset = jj_input_stream.bufline[jj_input_stream.bufpos];
    }
  }
}

PARSER_END(FiltexParserImpl)

/* For Debug */
JAVACODE
void debug_message1()
{
  LOGGER.info("{} , {}", getToken(0).image, getToken(1).image);
}

/** Parses a numeric filter expression followed by end-of-file. */
AstNode numericExpressionEof() :
{
  final AstNode n;
}
{
  n = numericExpression() <EOF> { return n; }
}


/** Parses a numeric expression. */
AstNode numericExpression() :
{
  final AstNode n;
}
{
  n = logicalExpression() { return n; }
|
  n = term() { return n; }
}

/** Parses a logical numeric expression. */
AstNode logicalExpression() :
{
  final AstNode left;
  final AstNode right;
}
{
  left = term() ( <COMMA> | <OR> ) right = numericExpression() {
    return ast.logicalExpression(left, right);
  }
}

/** Parses a numeric term. */
AstNode term() :
{
  final AstNode n;
  final boolean is;
  final AstNode right;
}
{
  n = userAttribute() { return n; }
|
  is = is()
  (
    <NULL> { term = Op.NULL; }
//  | term = intervalComp1()
//  | term = intervalComp2()
//  | term = intervalComp3()
//  | term = intervalComp4()
//  | <COMPARISON> { term = Op.NULL; }
//  | <TO> { term = Op.NULL; }
//  | <VALUE> { term = Op.NULL; }
  )
  ( <COMMA> | <OR> ) right = numericExpression() {
    return ast.call(Op.COMMA, left, right);
  }
|
  is = is() term = interval(is) { return term; }
}

boolean is() : {}
{
  <NOT> { return false; }
| <BANG_EQ> { return false; }
| <LT_GT> { return false; }
| { return true; }
}

/* Special rules for defining BETWEEN ranges using comparison operators with AND/OR */

/* >= 7 AND <80.44 becomes (7, 80.44) */
AstNode intervalComp1() : {}
{
  { return null; }
}

AstNode interval(boolean is) : {}
{
  { throw new UnsupportedOperationException(); }
/*
open:OPEN _ left:(number) _ COMMA _ right:(number) _ close:CLOSE {
  return {
    type: 'between',
      bounds: open + close,
      low: left,
      high: right
  }
} / open:OPEN _ left:(number) _ COMMA _  close:CLOSE {
      const type = open == '(' ? '>' : '>='
      const value = [left]
      return {type:type, value:value}
} /  open:OPEN _  COMMA _ right:(number) _ close:CLOSE {
      const type = close == ')' ? '<' : '<='
      const value = [right]
      return {type:type, value:value}
 } / "(" _ "-inf" _ COMMA _ right:(number) _ close:CLOSE {
      const type = close == ')' ? '<' : '<='
      const value = [right]
      return {type:type, value:value}
 } / open:OPEN _ left:(number) _ COMMA _ "inf" _ ")" {
      const type = open == '(' ? '>' : '>='
      const value = [left]
      return {type:type, value:value}
 }
 */
}

AstNode userAttribute() : {}
{
  <DOUBLE_LBRACE> "_user_attributes[" "]" <DOUBLE_RBRACE> {
    throw new UnsupportedOperationException("userAttribute");
  }
}

/* LITERALS */

<DEFAULT> TOKEN :
{
    < NON_NEGATIVE_INTEGER_LITERAL: (["0"-"9"])+ >
    |
    < NEGATIVE_INTEGER_LITERAL: "~"(["0"-"9"])+ >
    |
    < REAL_LITERAL: ("~")?(["0"-"9"])+ "." (["0"-"9"])+ >
    |
    < SCIENTIFIC_LITERAL: ("~")?(["0"-"9"])+
                          ("." (["0"-"9"])+)?
                          ["e", "E"] ("~")?(["0"-"9"])+>
    |
    < #HEXDIGIT: ["0"-"9","a"-"f","A"-"F"] >
    |
    < #WHITESPACE:
    [ " ","\t","\n","\r","\f" ]
    >
    |
    < QUOTED_STRING: <DOUBLE_QUOTE> ( (~["\"", "\\"]) | ("\\" "\"") | ("\\" "\\") )* <DOUBLE_QUOTE> >
    |
    < CHAR_LITERAL: ("#") <QUOTED_STRING> >
    |
    < NOT: "NOT" >
|   < BANG_EQ: "!=" >
|   < LT_GT: "<>" >
|   < COMMA: "," >
|   < OR: "OR" >
|   < DOUBLE_LBRACE: "{{" >
|   < DOUBLE_RBRACE: "}}" >
|   < NULL: "NULL" >
}

<DEFAULT> TOKEN :
{
    < EQ: "=" >
    | < DOUBLE_QUOTE: "\"" >
}

// End FiltexParser.jj
