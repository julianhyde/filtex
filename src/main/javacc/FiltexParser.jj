/*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 */

options {
  STATIC = false;
  IGNORE_CASE = true;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(FiltexParserImpl)

package net.hydromatic.filtex.parse;

import net.hydromatic.filtex.ast.Ast;
import net.hydromatic.filtex.ast.Ast.*;
import net.hydromatic.filtex.ast.AstNode;
import net.hydromatic.filtex.ast.Bound;
import net.hydromatic.filtex.ast.Location;
import net.hydromatic.filtex.ast.Op;
import net.hydromatic.filtex.ast.Pos;
import net.hydromatic.filtex.ast.Unit;

import com.google.common.collect.ImmutableList;

import net.hydromatic.filtex.ast.Unit;import org.checkerframework.checker.nullness.qual.Nullable;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import static net.hydromatic.filtex.ast.AstBuilder.ast;

/**
 * Parser for filter expressions, generated from FiltexParser.jj by JavaCC.
 */
public class FiltexParserImpl implements FiltexParser {
  private static final Logger LOGGER =
      LoggerFactory.getLogger("net.hydromatic.filtex.parse");

  private int lineOffset;
  private String file = "";

  public void setTabSize(int tabSize) {
    jj_input_stream.setTabSize(tabSize);
  }

  public Pos pos() {
    return new Pos(file,
        token.beginLine - lineOffset, token.beginColumn,
        token.endLine - lineOffset, token.endColumn + 1);
  }

  public void zero(String file) {
    this.file = file;
    if (jj_input_stream.bufpos >= 0) {
      this.lineOffset = jj_input_stream.bufline[jj_input_stream.bufpos];
    }
  }
}

PARSER_END(FiltexParserImpl)

/* For Debug */
JAVACODE
void debug_message1()
{
  LOGGER.info("{} , {}", getToken(0).image, getToken(1).image);
}

/** Parses a location filter expression followed by end-of-file. */
AstNode locationExpressionEof() : {
  final AstNode node;
}
{
  node = locationExpression() <EOF> { return node; }
}

/** Parses a numeric filter expression followed by end-of-file. */
AstNode numericExpressionEof() : {
  final AstNode node;
}
{
  node = numericExpression() <EOF> { return node; }
}

// == Location ===============================================================

/** Parses a location expression.
 *
 * <p>Accepts expressions like:
 * "{@code 36.97, -122.03}",
 * "{@code 40 miles from 36.97, -122.03}",
 * "{@code inside box from 72.33, -173.14 to 14.39, -61.70}"
 */
AstNode locationExpression() : {
  final AstNode node;
  final Location location;
}
{
  LOOKAHEAD(2) // distinguish location (number comma) from circle (number unit)
  node = circle() { return node; }
| location = location() { return ast.point(location); }
| node = box() { return node; }
| node = userAttribute() { return node; }
| node = nulls() { return node; }
| node = anywhere() { return node; }
}

AstNode anywhere() : {}
{
  { return ast.anywhere(); }
}

AstNode nulls() : {}
{
  <NULL> { return ast.isNull(true); }
| <NOT> <NULL> { return ast.isNull(false); }
| "-" <NULL> { return ast.isNull(false); }
}

AstNode box() : {
  final Location from;
  final Location to;
}
{
  <INSIDE> <BOX> <FROM> from = location() <TO> to = location() {
    return ast.box(from, to);
  }
}

AstNode circle() : {
  final BigDecimal distance;
  final Unit unit;
  final Location location;
}
{
  distance = number()
  unit = unit() <FROM> location = location() {
    if (distance.signum() < 0) {
      throw new ParseException("expected a positive value");
    }
    return ast.circle(distance, unit, location);
  }
}

Location location() : {
  final BigDecimal latitude;
  final BigDecimal longitude;
}
{
  latitude = number() <COMMA> longitude = number() {
    if (latitude.compareTo(BigDecimal.valueOf(-90)) < 0
        || latitude.compareTo(BigDecimal.valueOf(90)) > 0) {
      throw new ParseException("expected a number between -90 and 90");
    }
    if (longitude.compareTo(BigDecimal.valueOf(-180)) < 0
        || longitude.compareTo(BigDecimal.valueOf(180)) > 0) {
      throw new ParseException("expected a number between -180 and 180");
    }
    return new Location(latitude, longitude);
  }
}

Unit unit() : {}
{
  <METERS> { return Unit.METER; }
| <FEET> { return Unit.FOOT; }
| <KILOMETERS> { return Unit.KILOMETER; }
| <MILES> { return Unit.MILE; }
}

// == Number =================================================================

/** Parses a numeric expression.
 *
 * <p>Accepts expressions like "not 66, 99, 4", "1 to 100"
 * and returns an AST.
 * See https://docs.looker.com/reference/filter-expressions#number
 *
 * <p>A top-level numeric expression is a comma-separated list of terms.
 */
AstNode numericExpression() : {
  final List<AstNode> list = new ArrayList<>();
}
{
  addTerm(list)
  ( ( <COMMA> | <OR> ) addTerm(list) )*
  { return ast.logicalExpression(list); }
}

/** Adds a term to a list. */
void addTerm(List<AstNode> list) : {
  final AstNode node;
}
{
  node = term() { list.add(node); }
}

/** Parses a numeric term. */
AstNode term() : {
  final boolean is;
  final AstNode node;
}
{
  node = userAttribute() { return node; }
|
  is = is()
  (
    <NULL> { node = ast.isNull(is); }
  | node = intervalComp1(is)
  | node = intervalComp2(is)
  | node = to(is)
  | node = interval(is)
  )
  { return node; }
}

/** Reads an optional prefix ("not", "&lt;&gt;", "!=") and returns whether the
 * following term should be negated. */
boolean is() : {}
{
  <NOT> { return false; }
| <BANG_EQ> { return false; }
| <LT_GT> { return false; }
| { return true; }
}

/* Special rules for defining BETWEEN ranges using comparison operators with AND/OR */

/** Special interval,
 * "{@code >= 7 AND <80.44}" becomes "(7, 80.44)", and
 * "{@code >=80.44 OR <.1}" becomes "(0.01, 80.44]".
 * Also parses comparison, "{@code > 10}". */
AstNode intervalComp1(boolean is) : {
 final Bound leftBound;
 final BigDecimal left;
 final BigDecimal right;
 final Bound rightBound;
 final boolean reverse;
}
{
  ( ">" { leftBound = Bound.OPEN; }
  | ">=" { leftBound = Bound.CLOSED; }
  )
  left = number()
  (
    ( <AND> { reverse = false; }
    | <OR> { reverse = true; }
    )
    ( "<" { rightBound = Bound.OPEN; }
    | "<=" { rightBound = Bound.CLOSED; }
    )
    right = number() {
      if (reverse) {
        // FIXME number_grammar.ts passes false, should pass !is
        return ast.between(!is, leftBound.flip(), rightBound.flip(), right,
            left);
      } else {
        return ast.between(is, leftBound, rightBound, left, right);
      }
    }
  |
    { return ast.between(is, leftBound, Bound.ABSENT, left, null); }
  )
}

/** Special interval, second kind;
 * "{@code <=80.44  AND    >.1}"  becomes "(0.01, 80.44]", and
 * "{@code <= 7 OR >80.44}" becomes "[7, 80.44)".
 * Also parses comparison, "{@code < 10}". */
AstNode intervalComp2(boolean is) : {
 final Bound leftBound;
 final BigDecimal left;
 final BigDecimal right;
 final Bound rightBound;
 final boolean reverse;
}
{
  ( "<" { leftBound = Bound.OPEN; }
  | "<=" { leftBound = Bound.CLOSED; }
  )
  left = number()
  (
    ( <AND> { reverse = false; }
    | <OR> { reverse = true; }
    )
    ( ">" { rightBound = Bound.OPEN; }
    | ">=" { rightBound = Bound.CLOSED; }
    )
    right = number() {
      if (reverse) {
        // FIXME number_grammar.ts passes false, should pass !is
        return ast.between(!is, rightBound.flip(), leftBound.flip(), left, right);
      } else {
        return ast.between(is, rightBound, leftBound, right, left);
      }
    }
  |
    { return ast.between(is, Bound.ABSENT, leftBound, null, left); }
  )
}

/** Parses a range (such as "5 to 10", "to 10", "5 to"), and also a numeric
 * literal (such as "5"). */
AstNode to(boolean is) : {
  final BigDecimal begin;
  final BigDecimal end;
}
{
  begin = number()
  (
    <TO>
    (
      end = number() {
        return ast.between(is, Bound.CLOSED, Bound.CLOSED, begin, end);
      }
    | { return ast.between(Op.CLOSED_ABSENT, is, begin); }
    )
  | { return ast.numberLiteral(is, begin); }
  )
|
  <TO> end = number() {
    return ast.between(Op.ABSENT_CLOSED, is, end);
  }
}

AstNode interval(boolean is) : {
 Bound leftBound;
 final @Nullable BigDecimal left;
 final @Nullable BigDecimal right;
 Bound rightBound;
}
{
  ( "(" { leftBound = Bound.OPEN; } | "[" { leftBound = Bound.CLOSED; } )
  (
    left = number()
  | ("-inf")? { left = null; }
  )
  <COMMA>
  (
    right = number()
  | ("inf")? { right = null; }
  )
  ( ")" { rightBound = Bound.OPEN; } | "]" { rightBound = Bound.CLOSED; } ) {
    // FIXME: Grammar allows both bounds absent, e.g. '[,]' and '(-inf,inf)'
    //   but should not
    if (left == null) {
      leftBound = Bound.ABSENT;
    }
    if (right == null) {
      rightBound = Bound.ABSENT;
    }
    if (left == null && right == null) {
      throw new ParseException("unbounded interval");
    }
    return ast.between(is, leftBound, rightBound, left, right);
  }
}

AstNode userAttribute() : {}
{
  <DOUBLE_LBRACE> "_user_attributes[" "]" <DOUBLE_RBRACE> {
    throw new UnsupportedOperationException("userAttribute");
  }
}

BigDecimal number() : {}
{
  ( <NUMBER_LITERAL> | <NUMBER_LITERAL0> ) { return new BigDecimal(token.image); }
}

/* LITERALS */

<DEFAULT> TOKEN :
{
  < NUMBER_LITERAL: ("-")?
      (["0"-"9"])+
      ("." (["0"-"9"])+)?
      (["e", "E"] ("-")?(["0"-"9"])+)? >
| < NUMBER_LITERAL0: ("-")?
      "." (["0"-"9"])+
      (["e", "E"] ("-")?(["0"-"9"])+)? >
| < QUOTED_STRING: <DOUBLE_QUOTE> ( (~["\"", "\\"]) | ("\\" "\"") | ("\\" "\\") )* <DOUBLE_QUOTE> >
}

<DEFAULT> SKIP :
{ " "
| "\t"
| "\n"
| "\r"
| "\f"
}

<DEFAULT> TOKEN :
{
  < #WHITESPACE: [ " ","\t","\n","\r","\f" ] >
}

<DEFAULT> TOKEN :
{
  < DOUBLE_QUOTE: "\"" >
| < CHAR_LITERAL: ("#") <QUOTED_STRING> >
| < BOX: "BOX" >
| < FROM: "FROM" >
| < INSIDE: "INSIDE" >
| < NOT: "NOT" >
| < AND: "AND" >
| < FEET: "FEET" >
| < METERS: "METERS" >
| < MILES: "MILES" >
| < KILOMETERS: "KILOMETERS" >
| < OR: "OR" >
| < BANG_EQ: "!=" >
| < LT_GT: "<>" >
| < COMMA: "," >
| < TO: "TO" >
| < DOUBLE_LBRACE: "{{" >
| < DOUBLE_RBRACE: "}}" >
| < NULL: "NULL" >
| < EQ: "=" >
}

// End FiltexParser.jj
